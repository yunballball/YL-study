<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width,initial-scale=1,minimum-scale=1,maximum-scale=1,user-scalable=no" />
      <meta name="format-detection" content="telephone=no" />
    <title>Document</title>
        <style type="text/css" media="screen">
        pre{background-color: #eee;padding: 10px;border: 1px solid #ccc;white-space: pre-wrap;}
    </style>
</head>
<body>
    <div>
      <h3>js基本数据类型有哪些？</h3>
      <p>undefined,null,number,string,boolean</p>
    </div>
    <div>
      <h3>有哪些内置对象？</h3>
      <p>Object 是 JavaScript 中所有对象的父对象 <br>数据封装类对象：String,Number,Boolean,Object,Array <br>
      其他对象：Date,Math,Event,Arguments,Regexp,Function
      </p>
    </div>

    <div>
      <h3>js有哪几种创建对象的方式？</h3>
      <p>对象字面量，内置对象（工厂方式），构造函数，原型方式，混合方式，自定义对象，使用json.</p>
      <pre>
        //字面量
        person={firstname:"Mark",lastname:"Yun",age:25,eyecolor:"black"};
        // 工厂方式
        function cPerson(name,sex,age){
 var o = new Object();
 o.name = name;
 o.sex = sex;
 o.age = age;
 o.show = function(){
 console.log(this.name,this.age,this.sex);
 }
 return o;
}
 var p1 = cPerson('谦龙','男','100');
 p1.show();
 var p2 = cPerson('雏田','女','14');
 p2.show();
      // 构造函数
      function Person(name,age,hobby) {
  this.name = name; //this作用域：当前对象
  this.age = age;
  this.work = work;
  this.info = function() {
      alert("我叫" + this.name + "，今年" + this.age + "岁，是个" + this.work);
  }
}
var Xiaosong = new Person("WooKong",23,"程序猿"); //实例化、
      //原型
      function Standard(){}
Standard.prototype.name = "ECMAScript";
Standard.prototype.event = function() {
  alert(this.name+"是脚本语言标准规范");
}
var jiaoben = new Standard();
jiaoben.event();

      //混合方式
      function iPhone(name,event) {
  this.name = name;
  this.event = event;
}
iPhone.prototype.sell = function() {
  alert("我是"+this.name+"，我是iPhone5s的"+this.event+"~ haha!");
}
var SE = new iPhone("iPhone SE","官方翻新机");
SE.sell();
      </pre>

    </div>
    <div>
      <h3>window和document的区别？</h3>
      <p>1.window指窗体，document指的是页面;document是window的一个子对象 <br>
2.用户不能改变document.location，但可以改变window.location, <br>
3.window.location是一个对象，document.location不是。

      </p>
    </div>
   
   <div>
     <h3>页面编码和被请求的资源编码如果不一致如何处理？</h3>
     <p>给script标签加charset属性</p>
   </div>
   <div>
     <h3>document.write 和 innerHTML 有何区别？</h3>
     <p>前者会导致页面重绘，后者只是部分标签内容重写。</p>
   </div>

   <div>
     <h3>如何编写高性能 JavaScript ？</h3>
     <p>
     http://developer.51cto.com/art/200906/131335.htm <br>
       1.使用 DocumentFragment 优化多次 append <br>
       2.循环拼接多个数组字符串，用join，不要用+  <br>
       3.尽量不要用for-in循环数组 <br>
       4.避免循环引用，防止内存泄漏。 <br>
       5.能用switch case就不要用 if elseif. <br>
       6.事件委托。
     </p>
   </div>

   <div>
     <p>谈一谈你对 ECMAScript6 的了解？</p>
     <pre>
       ECMAScript 6 是JavaScript语言的下一代标准，已经在2015年6月正式发布了。它的目标，是使得JavaScript语言可以用来编写复杂的大型应用程序，成为企业级开发语言。
标准的制定者有计划，以后每年发布一次标准，使用年份作为标准的版本。因为当前版本的ES6是在2015年发布的，所以又称ECMAScript 2015。也就是说，ES6就是ES2015
     </pre>
   </div>
   <div>
     <p>ECMAScript 6 怎么写 class ，为何会出现 class？</p>
     <pre>
     ES6的class可以看作只是一个语法糖，它的绝大部分功能，ES5都可以做到，新的class写法只是让对象原型的写法更加清晰、更像面向对象编程的语法而已。
     //定义类
class Point {
  constructor(x,y) {  //构造方法
      this.x = x;  //this关键字代表实例对象
      this.y = y;
}
  toString() {
      return '(' + this.x + ',' + this.y + ')';
  }
}
     //定义类
class Point {
  constructor(x,y) {  //构造方法
      this.x = x;  //this关键字代表实例对象
      this.y = y;
}
  toString() {
      return '(' + this.x + ',' + this.y + ')';
  }
}
       //定义类
class Point {
  constructor(x,y) {  //构造方法
      this.x = x;  //this关键字代表实例对象
      this.y = y;
}
  toString() {
      return '(' + this.x + ',' + this.y + ')';
  }
}
     </pre>
   </div>

   
  
  



  <div>
    <h3>如何判断当前脚本运行在浏览器还是 node 环境中？</h3>
    <p>通过判断window对象是否存在，不存在则当前脚本没有运行在浏览器中。</p>
  </div>
  <div>
    <h3>什么是“前端路由”？什么时候适合使用“前端路由”？“前端路由”有哪些优点和缺点？</h3>
   <pre>
     什么是前端路由？
路由是根据不同的 url 地址展示不同的内容或页面,前端路由就是把不同路由对应不同的内容或页面的任务交给前端来做。

2，什么时候使用前端路由？

在单页面应用，大部分页面结构不变，只改变部分内容的使用
3，前端路由有什么优点和缺点？

优点
用户体验好，不需要每次都从服务器全部获取，快速展现给用户
缺点
使用浏览器的前进，后退键的时候会重新发送请求，没有合理地利用缓存
单页面无法记住之前滚动的位置，无法在前进，后退的时候记住滚动的位置
   </pre>
  </div>

  <div>
    <h3>
      JavaScript 代码中的 "use strict"; 是什么意思？使用它的区别是什么？
    </h3>
    <pre>use strict是一种ECMAscript 5 添加的（严格）运行模式,这种模式使得 Javascript 在更严格的条件下运行,使JS编码更加规范化的模式,消除Javascript语法的一些不合理、不严谨之处，减少一些怪异行为。
默认支持的糟糕特性都会被禁用，比如不能用with，也不能在意外的情况下给全局变量赋值;
全局变量的显示声明,函数必须声明在顶层，不允许在非函数代码块内声明函数,arguments.callee也不允许使用；
消除代码运行的一些不安全之处，保证代码运行的安全,限制函数中的arguments修改，严格模式下的eval函数的行为和非严格模式的也不相同;
提高编译器效率，增加运行速度；
为未来新版本的Javascript标准化做铺垫。</pre>
  </div>

  <div>
    <h3>js 中，有一个函数，执行对象查找时，永远不会去查找原型，这个函数是哪个？</h3>
    <p><b>hasOwnProperty</b>,此方法是返回一个布尔值，指出一个对象是否具有指定名称的属性。此方法无法检查该对象的原型链中是否具有该属性；该属性必须是对象本身的一个成员。
使用方法：
object.hasOwnProperty(proName)
其中参数object是必选项，一个对象的实例。
proName是必选项，一个属性名称的字符串值。</p>
  </div>

  <div>
    <h3>js延迟加载的方式有哪些？</h3>
    <p>defer,async,动态创建dom方式，按需异步就载入js</p>
  </div>

  <div>
    <h3>DOM 操作——怎样添加、移除、移动、复制、创建和查找节点？</h3>
    <pre>
      (1)创建新节点
createDocumentFragment()    //创建一个DOM片段
createElement()   //创建一个具体的元素
createTextNode()   //创建一个文本节点
(2)添加、移除、替换、插入
appendChild()
removeChild()
replaceChild()
insertBefore() //在已有的子节点前插入一个新的子节点
(3)查找
getElementsByTagName()    //通过标签名称
getElementsByName()    //通过元素的Name属性的值(IE容错能力较强，会得到一个数组，其中包括id等于name值的)
getElementById()    //通过元素Id，唯一性
    </pre>
  </div>


  <div>
    <h3>列举几条 JavaScript 的基本代码规范。</h3>
    <pre>
      （1）不要在同一行声明多个变量
（2）如果你不知道数组的长度，使用 push
（3）请使用 ===/!== 来比较 true/false 或者数值
（4）对字符串使用单引号 ''(因为大多时候我们的字符串。特别html会出现")
（5）使用对象字面量替代 new Array 这种形式
（6）绝对不要在一个非函数块里声明一个函数，把那个函数赋给一个变量。浏览器允许你这么做，但是它们解析不同
（7）不要使用全局函数
（8）总是使用 var 来声明变量，如果不这么做将导致产生全局变量，我们要避免污染全局命名空间
（9）Switch 语句必须带有 default 分支
（10）使用 /**...*/ 进行多行注释，包括描述，指定类型以及参数值和返回值
（11）函数不应该有时候有返回值，有时候没有返回值
（12）语句结束一定要加分号
（13）for 循环必须使用大括号
（14）if 语句必须使用大括号
（15）for-in 循环中的变量应该使用 var 关键字明确限定作用域，从而避免作用域污染
（16）避免单个字符名，让你的变量名有描述意义
（17）当命名对象、函数和实例时使用驼峰命名规则
（18）给对象原型分配方法，而不是用一个新的对象覆盖原型，覆盖原型会使继承出现问题
（19）当给事件附加数据时，传入一个哈希而不是原始值，这可以让后面的贡献者加入更多数据到事件数据里，而不用找出并更新那个事件的事件处理器
    </pre>
  </div>

  <div>
    <h3>null 和 undefined 有何区别？</h3>
    <pre>
      null        表示一个对象被定义了，值为“空值”；
undefined   表示不存在这个值。
typeof undefined                   //"undefined"
  undefined :是一个表示"无"的原始值或者说表示"缺少值"，就是此处应该有一个值，但是还没有定义。当尝试读取时会返回 undefined； 
  例如变量被声明了，但没有赋值时，就等于undefined。
typeof null    //"object"
  null : 是一个对象(空对象, 没有任何属性和方法)；
  例如作为函数的参数，表示该函数的参数不是对象；
注意：在验证null时，一定要使用　=== ，因为 == 无法分别 null 和　undefined
    </pre>
  </div>

  <div>
    <h3>事件是什么？IE与火狐的事件机制有何区别？如何阻止冒泡？</h3>
    <pre>
(1)我们在网页中的某个操作（有的操作对应多个事件）。例如：当我们点击一个按钮就会产生一个事件。是可以被 JavaScript 侦测到的行为。
(2)事件处理机制：IE是事件冒泡、Firefox同时支持两种事件模型，也就是：捕获型事件和冒泡型事件；
(3)ev.stopPropagation();（旧ie的方法 ev.cancelBubble = true;）
    </pre>
  </div>

  <div>
    <h3>同步和异步的区别？</h3>
    <pre> 
同步的概念应该是来自于操作系统中关于同步的概念:
不同进程为协同完成某项工作而在先后次序上调整(通过阻塞,唤醒等方式)。同步强调的是顺序性，谁先谁后；异步则不存在这种顺序性。
同步：浏览器访问服务器请求，用户看得到页面刷新，重新发请求,等请求完，页面刷新，新内容出现，用户看到新内容,进行下一步操作。
异步：浏览器访问服务器请求，用户正常操作，浏览器后端进行请求。等请求完，页面不刷新，新内容也会出现，用户看到新内容。
    </pre>
  </div>

  <div>
    <h3>哪些操作会造成内存泄漏？</h3>
    <pre>
内存泄漏是指任何对象在您不再拥有或需要它之后仍然存在。
垃圾回收器定期扫描对象，并计算引用了每个对象的其他对象的数量，如果一个对象的引用数量为0（没有其他对象引用过该对象），或对该对象的惟一引用是循环的，那么该对象的内存即可回收。
setTimeout 的第一个参数使用字符串而非函数的话，会引发内存泄漏。
闭包、控制台日志、循环（在两个对象彼此引用且彼此保留时，就会产生一个循环）
    </pre>
  </div>

  <div>
    <h3>检测浏览器版本有哪些方式？</h3>
    <p>Navigator 对象包含有关浏览器的信息。navigator.userAgent</p>
  </div>

  <div>
    <h3>前端需要注意哪些SEO</h3>
    <pre>

1.合理的title、description、keywords：搜索对着三项的权重逐个减小，title值强调重点即可，重要关键词出现不要超过2次，而且要靠前，不同页面title要有所不同；description把页面内容高度概括，长度合适，不可过分堆砌关键词，不同页面description有所不同；keywords列举出重要关键词即可
2.语义化的HTML代码，符合W3C规范：语义化代码让搜索引擎容易理解网页
3.重要内容HTML代码放在最前：搜索引擎抓取HTMl顺序是从上到下，有的搜索引擎对抓取长度有限制，保证重要内容一定会被抓取
4.重要内容不要用js输出：爬虫不会执行js获取内容
5.少用iframe：搜索引擎不会抓取iframe中的内容
6.非装饰性图片必须加alt
7.提高网站速度：网站速度是搜索引擎排序的一个重要指标
    </pre>
  </div>

  <div>
    <h3>介绍一下 JavaScript 原型，原型链，它们有何特点？</h3>
    <pre>每个对象都会在其内部初始化一个属性，就是prototype(原型)，当我们访问一个对象的属性时，如果这个对象内部不存在这个属性，那么他就会去prototype里找这个属性，这个prototype又会有自己的prototype，于是就这样一直找下去，也就是我们平时所说的原型链的概念。
关系：instance.constructor.prototype = instance.__proto__
特点：Js对象是通过引用来传递的，我们创建的每个新对象实体中并没有一份属于自己的原型副本，当我们修改原型时，与之相关的对象也会继承这一改变。</pre>
  </div>
  



    <script type="text/javascript" src="js/jquery.js"></script>
    <script type="text/javascript">
     console.log(window.innerWidth);
   

    </script>   
</body>
</html>